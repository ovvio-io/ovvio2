import stableStringify from 'json-stable-stringify';
import Utils from '@ovvio/base/lib/utils';
import * as Base from './base';
import { AnnotationMap } from './annotations-map';
import * as RTTree from './richtext-tree2';
import * as PlainText from './plaintext';
import { ListChange } from './list';
import Change from './change';
import { isValidTree } from './richtext-tree-validation';

class EncodingDict {
  constructor(reservedCharCodes = ['\n']) {
    this.count = 1; // Skip the null character
    this.valuesToChars = new Map();
    this.charsToValues = new Map();
    this.reservedCharCodes = new Set(reservedCharCodes);
  }

  generateNewChar() {
    let code = this.count;
    while (this.reservedCharCodes.has(String.fromCharCode(code))) {
      ++code;
    }
    this.count = code + 1;
    return String.fromCharCode(code);
  }

  encodeStr(str) {
    return this.encodeValueForKey(str, str);
  }

  encodeValueForKey(key, value) {
    if (this.reservedCharCodes.has(key)) {
      return key;
    }
    let char = this.valuesToChars.get(key);
    if (!char) {
      char = this.generateNewChar();
      this.valuesToChars.set(key, char);
      this.charsToValues.set(char, value);
    }
    return char;
  }

  decodeChar(char) {
    return this.charsToValues.get(char);
  }
}

class DepthMarker {
  constructor(depth) {
    this.depth = depth;
    this.key = `_depth:${depth}`;
  }

  static markerForDepth(depth) {
    let cache = this._markersCache;
    if (!cache) {
      cache = new Map();
      this._markersCache = cache;
    }
    let marker = cache.get(depth);
    if (!marker) {
      marker = new this(depth);
      cache.set(depth, marker);
    }
    return marker;
  }

  toJS() {
    return { d: this.depth };
  }

  static fromJS(obj) {
    return this.markerForDepth(obj.d);
  }
}

class PointerMarker {
  constructor(key, data) {
    this.key = key;
    this.data = data;
  }
}

function _atomsForPtrMarker(k, data) {
  const marker = new PointerMarker(k, data);
  return [marker.key, marker];
}

/**
 * Given a node, this function yields an array of [key, atom] pairs used to
 * encode the node and its contents as a string. This function takes care of
 * inserting PointerMarker instances at the appropriate places, as well as
 * break nodes to their atoms.
 */
function* nodeToAtomsIter(node, ptrKeyFilter) {
  if (node.type === RTTree.TYPE_TEXT) {
    const text = node.text;
    const len = text.length;
    for (let idx = 0; idx < len; ++idx) {
      for (const [k, data] of node.ptrMap.valuesAtIndexIter(
        idx,
        ptrKeyFilter
      )) {
        yield _atomsForPtrMarker(k, data);
      }
      const char = text[idx];
      yield [char, char];
    }
    // Text nodes are allowed to hold pointers after the last index
    for (const [k, data] of node.ptrMap.valuesAtIndexIter(len, ptrKeyFilter)) {
      yield _atomsForPtrMarker(k, data);
    }
  } else {
    Utils.assert(node.length === 1);
    for (const [k, data] of node.ptrMap.valuesAtIndexIter(0, ptrKeyFilter)) {
      yield _atomsForPtrMarker(k, data);
    }
    if (node.type === RTTree.TYPE_ELEMENT) {
      // We encode elements as newlines so our plaintext diff implementation
      // can use all of its optimizations. The actual element data is stored
      // as annotations on this character.
      yield ['\n', '\n'];
    } else {
      yield [node.key, node];
    }
    for (const [k, data] of node.ptrMap.valuesAtIndexIter(1, ptrKeyFilter)) {
      yield _atomsForPtrMarker(k, data);
    }
  }
}

/**
 * Given a node, this function returns an AnnotationMap corrected for pointer
 * offsets that are generated by nodeToAtomsIter().
 */
function correctedAnnMapForNode(node, local) {
  const keyFilter = k => local || !RTTree.isAnnKeyLocal(k);
  let result = node.annMap;
  if (node.type === RTTree.TYPE_TEXT) {
    const text = node.text;
    const len = text.length;
    let pointerCount = 0;
    for (let idx = 0; idx < len; ++idx) {
      const ptrCount = node.ptrMap.countAtIndex(idx, keyFilter);
      if (ptrCount) {
        if (!annMap) {
          result = node.annMap.clone();
        }
        result.shiftIndexes(ptrCount, idx + pointerCount);
        pointerCount += ptrCount;
      }
    }
  } else {
    const ptrCount = node.ptrMap.countAtIndex(0, keyFilter);
    if (ptrCount) {
      result = node.annMap.clone();
      result.shiftIndexes(ptrCount);
    }
  }
  if (!local) {
    if (node.annMap === result && result.hasKeys(RTTree.isAnnKeyLocal)) {
      result = node.annMap.clone();
    }
    result.deleteKeys(RTTree.isAnnKeyLocal);
  }
  return result;
}

/**
 * Given a dict and an iterable of tree framents (nodes, depth markers, etc),
 * this function encodes them to a text and annMap pair.
 */
function encodeFragments(dict, fragmentsIter, local) {
  const charArr = [];
  const compositeAnnMap = new AnnotationMap();
  let len = 0;

  for (let value of fragmentsIter) {
    if (value instanceof DepthMarker) {
      charArr.push(dict.encodeValueForKey(value.key, value));
      ++len;
    } else if (value instanceof RTTree.Node) {
      for (const [key, atom] of nodeToAtomsIter(
        value,
        k => local || !RTTree.isAnnKeyLocal(k)
      )) {
        charArr.push(dict.encodeValueForKey(key, atom));
      }
      compositeAnnMap.update(correctedAnnMapForNode(value, local), len);
      len += value.length;
    } else {
      Utils.Error.notReached('Unknown value');
    }
  }

  return [charArr.join(''), compositeAnnMap];
}

/**
 * Given a root of a tree, this function yields all of its fragments.
 */
function* treeFragments(root, local) {
  let prevDepth = 1;
  let prevNode = root;
  for (let [n, depth] of root.dfs()) {
    if (!local && n.local) {
      continue;
    }
    if (
      depth < prevDepth ||
      (depth === prevDepth && prevNode.allowsChildren())
    ) {
      yield DepthMarker.markerForDepth(depth);
    }
    yield n;
    prevDepth = depth;
    prevNode = n;
  }
}

/**
 * Encodes a rich text tree into a string that can be diff'ed at the
 * character level. This string can only be diff'ed against an encoded string
 * generated with the same dict.
 *
 * @param dict An EncodingDict instance.
 *
 * @param root The root of the tree to encode.
 *
 * @returns An array of [text, annMap] representing the entire tree.
 */
function encodeTree(dict, root, local) {
  return encodeFragments(dict, treeFragments(root, local), local);
}

/**
 * Scan an array of characters and PointerMarkers and reconstruct the original
 * text and pointers.
 */
function _extractPointers(textValues, annMap) {
  const ptrMap = new AnnotationMap();
  let shiftedAnnMap = null;
  let text = '';
  // The last index at which we saw a character
  let charIdx = 0;
  for (let idx = 0; idx < textValues.length; ++idx) {
    const v = textValues[charIdx];
    // We may have a few markers in sequence. To reduce the number of expansive
    // shifts we make, we wait for the next real character to do the actual
    // shift
    if (v instanceof PointerMarker) {
      ptrMap.setValue(v.key, charIdx, v.data);
    } else {
      // Sanity check. We expect single characters here
      Utils.assert(v.length === 1);
      if (idx > charIdx + 1) {
        // Lazily create our shifted ann map. Most calls of this function will
        // have no pointers at all.
        if (!shiftedAnnMap) {
          shiftedAnnMap = annMap.clone();
        }
        shiftedAnnMap.shiftIndexes(charIdx - idx, idx);
      }
      text += v;
      ++charIdx;
    }
  }
  if (charIdx < textValues.length - 1) {
    if (!shiftedAnnMap) {
      shiftedAnnMap = annMap.clone();
    }
    shiftedAnnMap.shiftIndexes(charIdx - (textValues.length - 1), idx);
  }
  return {
    ptrMap: ptrMap,
    text: text,
    annMap: shiftedAnnMap || annMap,
  };
}

/**
 * Breaks an array of characters and PointerMarkers with annMap to a list of
 * TextNode instances that has consistent markers. Called from decodeSubtree
 * to decode runs of texts.
 */
function _extractTextNodes(textValues, annMap, outArray) {
  const { ptrMap, text, annMap: compactAnnMap } = _extractPointers(
    textValues,
    annMap
  );
  let lastCharIdx = 0;
  // Same thing as embed, but we also need to slice out the markers
  for (const [range, annotations] of annMap.fragmentsIter()) {
    // There may be gaps between fragments
    if (lastCharIdx < range.start) {
      const node = new RTTree.TextNode();
      node.text = text.substring(lastCharIdx, range.start);
      node.ptrMap.applyRanges(
        ptrMap.rangeIterator(lastCharIdx, range.start, true)
      );
      outArray.push(node);
    }

    const node = new RTTree.TextNode();
    node.text = text.substring(range.start, range.end);
    for (const k of Object.keys(annotations)) {
      node.annMap.setRange(k, 0, node.text.length, annotations[k]);
    }
    node.ptrMap.applyRanges(ptrMap.rangeIterator(range.start, range.end, true));
    outArray.push(node);
    lastCharIdx = range.end;
  }
  // Remainder
  if (lastCharIdx < text.length) {
    const node = new RTTree.TextNode();
    node.text = text.substring(lastCharIdx, text.length);
    node.ptrMap.applyRanges(
      ptrMap.rangeIterator(lastCharIdx, text.length, true)
    );
    outArray.push(node);
  }
}

/**
 * Converts an encoded text to an array of nodes.
 *
 * @param dict The EncodingDict instance that was used to encode the tree.
 *
 * @param text The encoded tree or subtree.
 *
 * @param annMap The annotations for the provided text.
 *
 * @returns An array of Nodes and DepthMarkers.
 */
function decodeSubtree(dict, text, annMap) {
  let decodedValues = [];
  let pendingTextValues = [];

  function pushPendingText(idx) {
    if (pendingTextValues.length) {
      _extractTextNodes(
        pendingTextValues,
        annMap.annotationsMapForRange(
          idx - pendingTextValues.length,
          idx,
          true
        ),
        decodedValues
      );
      pendingTextValues = [];
    }
  }

  // Go over each character and translate it back to the original value.
  // We join adjacent characters to a single text node and split on node
  // barriers.
  for (let idx = 0; idx < text.length; ++idx) {
    const char = text[idx];
    // Find the original value of this character
    if (char === '\n') {
      const nodeAnnMap = annMap.annotationsMapForRange(idx, idx + 1, true);
      // Skip elements that have absolutely no information about them
      // if (nodeAnnMap.isEmpty()) {
      //   continue;
      // }
      const node = new RTTree.ElementNode();
      node.annMap.update(nodeAnnMap);
      pushPendingText(idx);
      decodedValues.push(node);
    } else {
      const value = dict.decodeChar(char);
      // If we found a node we need to push any pending text nodes we've read
      if (value instanceof RTTree.Node || value instanceof DepthMarker) {
        pushPendingText(idx);
        if (value instanceof RTTree.Node) {
          decodedValues.push(value.clone(true));
        } else {
          decodedValues.push(value);
        }
      } else {
        pendingTextValues.push(value);
      }
    }
  }
  pushPendingText(text.length);
  return decodedValues;
}

/**
 * Reconstructs a tree from an array of nodes and depth markers.
 *
 * @param decodedValues An array returned from decodeTree().
 *
 * @param root The root of the reconstructed tree. Defaults to an empty
 *             element node.
 *
 * @returns The root of the tree (as provided);
 */
function reconstructTree(decodedValues, root = new RTTree.ElementNode()) {
  const ancestors = [root];
  let parentIdx = 0;
  for (const value of decodedValues) {
    if (value instanceof DepthMarker) {
      if (value.depth !== parentIdx + 1) {
        parentIdx = Math.min(value.depth - 1, ancestors.length - 1);
      }
    } else {
      if (parentIdx < ancestors.length - 1) {
        ancestors.splice(parentIdx + 1, ancestors.length - parentIdx - 1);
      }
      const node = value.clone(true);
      ancestors[parentIdx].appendChild(node);
      if (node.allowsChildren()) {
        ancestors.push(node);
      }
      parentIdx = ancestors.length - 1;
    }
  }
  return root;
}

/**
 * Converts the encoded text in each change back to an array of nodes
 */
function _decodeTextChanges(changes, dict) {
  const result = [];
  for (const c of changes) {
    // Convert each change's text back to a fragment of a tree
    const treeFragment = decodeSubtree(
      dict,
      c.value.text,
      c.value.annotationMap
    );

    if (!treeFragment.length) {
      continue;
    }
    result.push(new RichTextChange(c.kind, treeFragment, c.start, c.end));
  }
  return result;
}

function _decodeAnnChanges(annChanges, dict) {
  const result = [];
  const emptyAnnMap = new AnnotationMap();
  for (const c of annChanges) {
    // Convert each change's text back to a fragment of a tree
    const treeFragment = decodeSubtree(dict, c.text, emptyAnnMap);

    // if (!treeFragment.length) {
    //   continue;
    // }
    Utils.assert(treeFragment.length);

    result.push(
      new RichTextAnnChange(c.key, c.kind, c.position, c.value, treeFragment)
    );
  }
  return result;
}

/**
 * Diff two rich text trees.
 *
 * @param root1 The root node old tree.
 *
 * @param root2 The root node of the new tree.
 *
 * @param local If true, will include local data in the result. If false,
 *              local data is skipped.
 *
 * @returns RichTextDiff instance.
 */
export function diff(root1, root2, local) {
  if (RTTree.treesEqual(root1, root2)) {
    return new RichTextDiff([], []);
  }
  const dict = new EncodingDict();
  // Encode our trees as plaintext + annotations
  const [chars1, annMap1] = encodeTree(dict, root1, local);
  const [chars2, annMap2] = encodeTree(dict, root2, local);

  // Perform the diff at the plaintext domain
  const diff = PlainText.diffTexts(
    chars1,
    chars2,
    annMap1,
    annMap2,
    true,
    k => true //local || !RTTree.isAnnKeyLocal(k)
  );

  return new RichTextDiff(
    // Convert the text back to tree fragments
    _decodeTextChanges(diff.changes, dict),
    _decodeAnnChanges(diff.annChanges, dict),
    diff.diff
  );
}

export class RichTextDiff {
  constructor(changes, annChanges, dmpDiff) {
    this.changes = changes;
    this.annChanges = annChanges;
    this.dmpDiff = dmpDiff;
  }

  toJS() {
    return {
      c: this.changes.map(c => c.toJS()),
      a: this.annChanges.map(c => c.toJS()),
    };
  }

  append(otherDiff) {
    Utils.Array.append(this.changes, otherDiff.changes);
    Utils.Array.append(this.annChanges, otherDiff.annChanges);
  }

  stampTreeChanges(dataObj, override = false) {
    const entries = Object.entries(dataObj);
    for (const c of this.changes) {
      const treeFragment = c.value;
      for (const node of treeFragment) {
        const annMap = node.annMap;
        for (let idx = 0; idx < node.length; ++idx) {
          for (const [key, value] of entries) {
            if (override || !annMap.hasValue(key, idx)) {
              annMap.setValue(key, idx, value);
            }
          }
        }
      }
    }
  }

  isTrivial() {
    return !this.changes.length && !this.annChanges.length;
  }

  clone() {
    return new this.constructor(
      Array.from(this.changes),
      Array.from(this.annChanges)
    );
  }

  static fromJS(obj) {
    return new this(
      obj.c.map(c => Change.fromJS(c)),
      obj.a.map(c => Change.fromJS(c))
    );
  }

  static trivialDiff() {
    return new this([], []);
  }
}

/**
 * Given the result of diff(), this functions returns whether or not there are
 * changes in the computed patch.
 */
export function isTrivialDiff(rtdiff) {
  return !rtdiff || rtdiff.isTrivial();
}

function RTChangeToListChange(dict, rtChange) {
  const [encodedText, annMap] = encodeFragments(dict, rtChange.value, true);
  let kind = rtChange.kind;
  // If we're deleting a single text node, it'll get marked as a DELETE
  // but we may need to delete more than one character in reality. In this
  // case we fix the change kind to match the result we really want.
  if (kind === Base.CHANGE_DELETE && encodedText.length > 1) {
    kind = Base.CHANGE_DELETE_RANGE;
  }
  return new ListChange(
    kind,
    new PlainText.PlainText(encodedText, annMap),
    rtChange.start,
    rtChange.end
  );
}

function RTAChangeToListChange(dict, rtaChange) {
  const [encodedText] = encodeFragments(dict, rtaChange.treeFragment, true);
  return new PlainText.AnnotationChange(
    rtaChange.key,
    rtaChange.kind,
    rtaChange.position,
    rtaChange.value,
    encodedText
  );
}

export function patch(root, rtdiff) {
  if (isTrivialDiff(rtdiff)) {
    return root.clone();
  }
  const dict = new EncodingDict();
  let [text, annMap] = encodeTree(dict, root, true);
  ({ text, annMap } = PlainText.patchText(
    text,
    rtdiff.changes.map(c => RTChangeToListChange(dict, c)),
    annMap,
    rtdiff.annChanges.map(c => RTAChangeToListChange(dict, c))
  ));
  const result = reconstructTree(decodeSubtree(dict, text, annMap, true));
  result.normalize();
  Utils.assert(isValidTree(result));
  return result;
}

function encodeValueForChange(value) {
  let type;

  if (value instanceof DepthMarker) {
    type = 'd';
  } else {
    type = 'n';
  }
  return { t: type, v: value.toJS() };
}

function decodeValueForChange(obj) {
  let value;
  switch (obj.t) {
    case 'd':
      return DepthMarker.fromJS(obj.v);

    case 'n':
      return RTTree.Node.fromJS(obj.v);

    default:
      throw new Error('Unknown value type');
  }
}

class RichTextChange extends ListChange {
  get type() {
    return 'RT2';
  }

  toJSImpl() {
    return {
      k: this.kind,
      v: this.value.map(v => encodeValueForChange(v)),
      s: this.start,
      e: this.end,
    };
  }
  static fromJS(obj) {
    return new this(
      obj.k,
      obj.v.map(v => decodeValueForChange(v)),
      obj.s,
      obj.e
    );
  }
}

class RichTextAnnChange extends Change.BaseChange {
  constructor(key, kind, position, value, treeFragment) {
    super();
    this.key = key;
    this.kind = kind;
    this.position = position;
    this.value = value;
    this.treeFragment = treeFragment;
  }

  get type() {
    return 'RTA';
  }

  toJSImpl() {
    return {
      key: this.key,
      k: this.kind,
      p: this.position,
      v: this.value,
      t: this.treeFragment.map(v => encodeValueForChange(v)),
    };
  }

  static fromJS(obj) {
    return new this(
      obj.key,
      obj.k,
      obj.p,
      obj.v,
      obj.t.map(v => decodeValueForChange(v))
    );
  }
}

Change.registerType('RT2', RichTextChange);
Change.registerType('RTA', RichTextAnnChange);
